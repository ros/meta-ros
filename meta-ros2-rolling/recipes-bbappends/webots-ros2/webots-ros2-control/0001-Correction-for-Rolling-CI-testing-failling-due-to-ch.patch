From 8ef85d52374b3e66e1073ace6efb4c0ee3cad5bb Mon Sep 17 00:00:00 2001
From: Benjamin Hug <61198898+BenjaminHug8@users.noreply.github.com>
Date: Wed, 3 Nov 2021 11:21:03 +0100
Subject: [PATCH] Correction for Rolling CI testing failling due to change in
 ros2control (base_interface) (#315)

* compliance CI folling foxy testing main from TIMPLE ros2control change base interface

* fix compliance

* cast double in int

* new fix cast int

* review github

* update .yaml

* debug and clean conversion duration

* Update test.yml

* fix rolling and galactic testing

* fix merge of rolling testing in main

Co-authored-by: Olivier Michel <Olivier.Michel@cyberbotics.com>

Upstream-Status: Backport [https://github.com/cyberbotics/webots_ros2/commit/be0458653f8f24d130589dbcd0c9faf5db8fac41]

Signed-off-by: Martin Jansa <martin.jansa@lge.com>
---
 CMakeLists.txt                                |  5 ++
 include/webots_ros2_control/Ros2Control.hpp   |  7 ++-
 .../webots_ros2_control/Ros2ControlSystem.hpp | 20 +++++--
 .../Ros2ControlSystemInterface.hpp            | 26 ++++++---
 src/Ros2Control.cpp                           | 14 ++++-
 src/Ros2ControlSystem.cpp                     | 57 +++++++++++++------
 6 files changed, 96 insertions(+), 33 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 69d7d260..bad5d36a 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,6 +1,11 @@
 cmake_minimum_required(VERSION 3.5)
 project(webots_ros2_control)
 
+# Check which ROS distribution is used, ros2control depends of that
+if($ENV{ROS_DISTRO} MATCHES "foxy")
+  add_compile_definitions(FOXY)
+endif()
+
 # Default to C99
 if(NOT CMAKE_C_STANDARD)
   set(CMAKE_C_STANDARD 99)
diff --git a/include/webots_ros2_control/Ros2Control.hpp b/include/webots_ros2_control/Ros2Control.hpp
index b0f317dc..49a96876 100644
--- a/include/webots_ros2_control/Ros2Control.hpp
+++ b/include/webots_ros2_control/Ros2Control.hpp
@@ -20,12 +20,15 @@
 #include <vector>
 #include <thread>
 
-#include "hardware_interface/base_interface.hpp"
+#if FOXY
+  #include "hardware_interface/base_interface.hpp"
+  #include "hardware_interface/types/hardware_interface_status_values.hpp"
+#endif
+
 #include "hardware_interface/system_interface.hpp"
 #include "hardware_interface/handle.hpp"
 #include "hardware_interface/hardware_info.hpp"
 #include "hardware_interface/types/hardware_interface_return_values.hpp"
-#include "hardware_interface/types/hardware_interface_status_values.hpp"
 #include "controller_manager/controller_manager.hpp"
 #include "rclcpp/macros.hpp"
 #include "webots_ros2_driver/PluginInterface.hpp"
diff --git a/include/webots_ros2_control/Ros2ControlSystem.hpp b/include/webots_ros2_control/Ros2ControlSystem.hpp
index bc6c6118..285325eb 100644
--- a/include/webots_ros2_control/Ros2ControlSystem.hpp
+++ b/include/webots_ros2_control/Ros2ControlSystem.hpp
@@ -19,12 +19,15 @@
 #include <string>
 #include <vector>
 
-#include "hardware_interface/base_interface.hpp"
+#if FOXY
+  #include "hardware_interface/base_interface.hpp"
+  #include "hardware_interface/types/hardware_interface_status_values.hpp"
+#endif
+
 #include "hardware_interface/system_interface.hpp"
 #include "hardware_interface/handle.hpp"
 #include "hardware_interface/hardware_info.hpp"
 #include "hardware_interface/types/hardware_interface_return_values.hpp"
-#include "hardware_interface/types/hardware_interface_status_values.hpp"
 #include "rclcpp/macros.hpp"
 #include "webots_ros2_driver/PluginInterface.hpp"
 #include "webots_ros2_driver/WebotsNode.hpp"
@@ -55,11 +58,18 @@ namespace webots_ros2_control
   public:
     void init(webots_ros2_driver::WebotsNode *node, const hardware_interface::HardwareInfo &info) override;
 
-    hardware_interface::return_type configure(const hardware_interface::HardwareInfo &info) override;
+    #if FOXY
+      hardware_interface::return_type configure(const hardware_interface::HardwareInfo &info) override;
+      hardware_interface::return_type start() override;
+      hardware_interface::return_type stop() override;
+    #else
+      CallbackReturn on_init(const hardware_interface::HardwareInfo &info) override;
+      CallbackReturn on_activate(const rclcpp_lifecycle::State & /*previous_state*/) override;
+      CallbackReturn on_deactivate(const rclcpp_lifecycle::State & /*previous_state*/) override;
+    #endif
+
     std::vector<hardware_interface::StateInterface> export_state_interfaces() override;
     std::vector<hardware_interface::CommandInterface> export_command_interfaces() override;
-    hardware_interface::return_type start() override;
-    hardware_interface::return_type stop() override;
     hardware_interface::return_type read() override;
     hardware_interface::return_type write() override;
 
diff --git a/include/webots_ros2_control/Ros2ControlSystemInterface.hpp b/include/webots_ros2_control/Ros2ControlSystemInterface.hpp
index 915cba65..463136b4 100644
--- a/include/webots_ros2_control/Ros2ControlSystemInterface.hpp
+++ b/include/webots_ros2_control/Ros2ControlSystemInterface.hpp
@@ -19,23 +19,35 @@
 #include <string>
 #include <vector>
 
-#include "hardware_interface/base_interface.hpp"
+#if FOXY
+  #include "hardware_interface/base_interface.hpp"
+  #include "hardware_interface/types/hardware_interface_status_values.hpp"
+#endif
+
 #include "hardware_interface/system_interface.hpp"
 #include "hardware_interface/handle.hpp"
 #include "hardware_interface/hardware_info.hpp"
 #include "hardware_interface/types/hardware_interface_return_values.hpp"
-#include "hardware_interface/types/hardware_interface_status_values.hpp"
 #include "webots_ros2_driver/PluginInterface.hpp"
 #include <webots/Supervisor.hpp>
 #include "webots_ros2_driver/WebotsNode.hpp"
 
 namespace webots_ros2_control
 {
-  class Ros2ControlSystemInterface : public hardware_interface::BaseInterface<hardware_interface::SystemInterface>
-  {
-  public:
-    virtual void init(webots_ros2_driver::WebotsNode *node, const hardware_interface::HardwareInfo &info) = 0;
-  };
+  #if FOXY
+    class Ros2ControlSystemInterface : public hardware_interface::BaseInterface<hardware_interface::SystemInterface>
+    {
+    public:
+      virtual void init(webots_ros2_driver::WebotsNode *node, const hardware_interface::HardwareInfo &info) = 0;
+    };
+  #else
+    class Ros2ControlSystemInterface : public hardware_interface::SystemInterface
+    {
+    public:
+      virtual void init(webots_ros2_driver::WebotsNode *node, const hardware_interface::HardwareInfo &info) = 0;
+    };
+  #endif
+  
 }
 
 #endif
diff --git a/src/Ros2Control.cpp b/src/Ros2Control.cpp
index 10d57aca..740d8f12 100644
--- a/src/Ros2Control.cpp
+++ b/src/Ros2Control.cpp
@@ -33,7 +33,12 @@ namespace webots_ros2_control
   void Ros2Control::step()
   {
     mControllerManager->read();
-    mControllerManager->update();
+    #if FOXY
+      mControllerManager->update();
+    #else
+      rclcpp::Duration dt = rclcpp::Duration::from_nanoseconds(RCL_MS_TO_NS(mNode->robot()->getBasicTimeStep()));
+      mControllerManager->update(mNode->get_clock()->now(), dt);
+    #endif
     mControllerManager->write();
   }
 
@@ -72,7 +77,12 @@ namespace webots_ros2_control
       auto webotsSystem = std::unique_ptr<webots_ros2_control::Ros2ControlSystemInterface>(
           mHardwareLoader->createUnmanagedInstance(hardwareType));
       webotsSystem->init(mNode, controlHardware[i]);
-      resourceManager->import_component(std::move(webotsSystem));
+//      MJ: not yet, maybe next time hardware-interface is updated in rolling
+//      #if FOXY
+        resourceManager->import_component(std::move(webotsSystem));
+//      #else
+//        resourceManager->import_component(std::move(webotsSystem), controlHardware[i]);
+//      #endif
     }
 
     // Controller Manager
diff --git a/src/Ros2ControlSystem.cpp b/src/Ros2ControlSystem.cpp
index 9a9b9a22..84badfaf 100644
--- a/src/Ros2ControlSystem.cpp
+++ b/src/Ros2ControlSystem.cpp
@@ -66,15 +66,26 @@ namespace webots_ros2_control
     }
   }
 
-  hardware_interface::return_type Ros2ControlSystem::configure(const hardware_interface::HardwareInfo &info)
-  {
-    if (configure_default(info) != hardware_interface::return_type::OK)
+  #if FOXY
+    hardware_interface::return_type Ros2ControlSystem::configure(const hardware_interface::HardwareInfo &info)
     {
-      return hardware_interface::return_type::ERROR;
+      if (configure_default(info) != hardware_interface::return_type::OK)
+      {
+        return hardware_interface::return_type::ERROR;
+      }
+      status_ = hardware_interface::status::CONFIGURED;
+      return hardware_interface::return_type::OK;
     }
-    status_ = hardware_interface::status::CONFIGURED;
-    return hardware_interface::return_type::OK;
-  }
+  #else
+    CallbackReturn Ros2ControlSystem::on_init(const hardware_interface::HardwareInfo &info)
+    {
+      if (hardware_interface::SystemInterface::on_init(info) != CallbackReturn::SUCCESS)
+      {
+        return CallbackReturn::ERROR;
+      }
+      return CallbackReturn::SUCCESS;
+    }
+  #endif
 
   std::vector<hardware_interface::StateInterface> Ros2ControlSystem::export_state_interfaces()
   {
@@ -102,17 +113,29 @@ namespace webots_ros2_control
     return interfaces;
   }
 
-  hardware_interface::return_type Ros2ControlSystem::start()
-  {
-    status_ = hardware_interface::status::STARTED;
-    return hardware_interface::return_type::OK;
-  }
+  #if FOXY
+    hardware_interface::return_type Ros2ControlSystem::start()
+    {
+      status_ = hardware_interface::status::STARTED;
+      return hardware_interface::return_type::OK;
+    }
 
-  hardware_interface::return_type Ros2ControlSystem::stop()
-  {
-    status_ = hardware_interface::status::STOPPED;
-    return hardware_interface::return_type::OK;
-  }
+    hardware_interface::return_type Ros2ControlSystem::stop()
+    {
+      status_ = hardware_interface::status::STOPPED;
+      return hardware_interface::return_type::OK;
+    }
+  #else
+    CallbackReturn Ros2ControlSystem::on_activate(const rclcpp_lifecycle::State & /*previous_state*/)
+    {
+      return CallbackReturn::SUCCESS;
+    }
+
+    CallbackReturn Ros2ControlSystem::on_deactivate(const rclcpp_lifecycle::State & /*previous_state*/)
+    {
+      return CallbackReturn::SUCCESS;
+    }
+  #endif
 
   hardware_interface::return_type Ros2ControlSystem::read()
   {
